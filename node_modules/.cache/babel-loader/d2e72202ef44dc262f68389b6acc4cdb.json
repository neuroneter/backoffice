{"ast":null,"code":"import firebase from './Firebase.js';\nimport { reset } from 'redux-form';\nvar db = firebase.firestore(); //Busca un registro puntual utilizando una llave o value fijo para en un campo o file \n\nfunction dbFindRegister(dispatch, type, colletion, file, value) {\n  db.collection(colletion).where(file, \"==\", value).get().then(function (snapshot) {\n    snapshot.forEach(function (doc) {\n      dispatch({\n        type: type,\n        data: doc.data()\n      });\n    });\n  }).catch(function (error) {\n    console.log(\"Error getting documents: \" + error);\n  });\n} //Recupera todos los valores de una Collection de datos \n\n\nfunction dbFindColletion(dispatch, type, colletion) {\n  //Hacemos la llamada a la bd para buscar todos los datos de una collection\n  db.collection(colletion).get().then(function (snapshot) {\n    dispatch({\n      type: type,\n      data: snapshot\n    });\n  }).catch(function (error) {\n    console.log(\"Error getting documents: \" + error);\n  });\n} //Crea un nuevo registro en la base de datos \n\n\nfunction dbCreate(dispatch, type, colletion, component, e) {\n  //Recuperamos todos los objetos que tienen una etiqueta refs\n  var dateRef = e.refs;\n  var formData = {};\n  var latitude = 0;\n  var longitude = 0;\n  var valorTmp = ''; //Recorremos el array con todas las etiquetas refs\n\n  for (var field in dateRef) {\n    //Recuperamos el valor que tiene el objeto del formulario \n    valorTmp = document.getElementById(field).value; //Como los tipos Geopoint se component de dos datos tenemos un if que nos permite identificarlos para posteriormente construir el array que correponde a la cordenada\n\n    if (dateRef[field].props.format == 'latitude') latitude = parseFloat(valorTmp);else if (dateRef[field].props.format == 'longitude') longitude = parseFloat(valorTmp);else formData[field] = valorTmp; //Al utilizar maskaras en input utilizamos el caracter * que rechena valores blancos por lo que antes de almacenar \n    //en la bd tenemos que retirar estos caracteres\n  }\n\n  if (latitude != 0 && longitude != 0) formData[\"geopoint\"] = new firebase.firestore.GeoPoint(latitude, longitude); //Procedemos ha ingresar el valor en la collection, utilizando como documento id un valor autogenerado \n  //dejamos que Firebase sea quien lo genere \n\n  db.collection(colletion).add(formData).then(function (docRef) {\n    //agregamos al objeto nuevo el valor retornado de identificación \n    formData[\"documentId\"] = docRef.id; //Para tener los listados actualizados reseteamos el componente listado\n\n    dispatch(reset(component)); //Ahora procedemos a llamar la funcion dispatcher quien se encargara de adicionar al state el nuevo objeto \n    //sin tener que realizar una consulta a la bd para recargar los datos.\n\n    dispatch({\n      type: type,\n      data: formData\n    });\n  }).catch(function (error) {\n    console.error(\"Error al crear documento \", error);\n  });\n} //Eliminar un registro o documento en una collection\n\n\nfunction dbDelete(dispatch, type, colletion, component, documentId) {\n  db.collection(colletion).doc(documentId).delete().then(function () {\n    dispatch(reset(component));\n    dispatch({\n      type: type,\n      data: documentId\n    });\n  }).catch(function (error) {\n    console.error(\"Error removing document: \", error);\n  });\n} //Actualizar un registro\n\n\nfunction dbUpdate(dispatch, type, colletion, component, e) {}\n\nvar DbCrud = {\n  dbFindRegister: dbFindRegister,\n  dbFindColletion: dbFindColletion,\n  dbCreate: dbCreate,\n  dbDelete: dbDelete\n};\nexport default DbCrud;","map":{"version":3,"sources":["/Users/danielobedortegahernandez/Documents/GitHub/bobSeller/src/Pojo/DbCrud.js"],"names":["firebase","reset","db","firestore","dbFindRegister","dispatch","type","colletion","file","value","collection","where","get","then","snapshot","forEach","doc","data","catch","error","console","log","dbFindColletion","dbCreate","component","e","dateRef","refs","formData","latitude","longitude","valorTmp","field","document","getElementById","props","format","parseFloat","GeoPoint","add","docRef","id","dbDelete","documentId","delete","dbUpdate","DbCrud"],"mappings":"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","sourcesContent":["import firebase from './Firebase.js';\nimport { reset } from 'redux-form';\nlet db = firebase.firestore();\n\n\n//Busca un registro puntual utilizando una llave o value fijo para en un campo o file \nfunction dbFindRegister(dispatch, type, colletion, file, value){\n    db.collection(colletion)\n        .where(file, \"==\", value).get()\n        .then(function(snapshot) {\n            snapshot.forEach(function (doc) {\n                dispatch({type:type,data:doc.data()})\n            });\n        })\n        .catch(function(error) {\n            console.log(\"Error getting documents: \"+error);\n    });\n}\n\n//Recupera todos los valores de una Collection de datos \nfunction dbFindColletion(dispatch, type, colletion){\n    //Hacemos la llamada a la bd para buscar todos los datos de una collection\n    db.collection(colletion)\n    .get()\n    .then(function(snapshot) {\n        dispatch({type:type,data:snapshot});\n    })\n    .catch(function(error) {\n        console.log(\"Error getting documents: \"+error);\n    });\n}\n\n//Crea un nuevo registro en la base de datos \nfunction dbCreate(dispatch, type, colletion, component, e){\n    //Recuperamos todos los objetos que tienen una etiqueta refs\n    const dateRef = e.refs;\n    const formData = {};\n    var latitude = 0;\n    var longitude = 0;\n    var valorTmp = '';\n    //Recorremos el array con todas las etiquetas refs\n    for (const field in dateRef){\n        //Recuperamos el valor que tiene el objeto del formulario \n        valorTmp = document.getElementById(field).value;\n        //Como los tipos Geopoint se component de dos datos tenemos un if que nos permite identificarlos para posteriormente construir el array que correponde a la cordenada\n        if(dateRef[field].props.format == 'latitude') latitude = parseFloat(valorTmp);\n        else if(dateRef[field].props.format == 'longitude') longitude = parseFloat(valorTmp);\n        else formData[field] = valorTmp;\n        //Al utilizar maskaras en input utilizamos el caracter * que rechena valores blancos por lo que antes de almacenar \n        //en la bd tenemos que retirar estos caracteres\n    }\n   \n   if(latitude != 0 && longitude != 0) formData[\"geopoint\"] = new firebase.firestore.GeoPoint( latitude, longitude);\n   //Procedemos ha ingresar el valor en la collection, utilizando como documento id un valor autogenerado \n   //dejamos que Firebase sea quien lo genere \n   db.collection(colletion).add(formData)\n   .then(function(docRef) { \n       //agregamos al objeto nuevo el valor retornado de identificación \n       formData[\"documentId\"] = docRef.id;\n       //Para tener los listados actualizados reseteamos el componente listado\n       dispatch(reset(component));\n       //Ahora procedemos a llamar la funcion dispatcher quien se encargara de adicionar al state el nuevo objeto \n       //sin tener que realizar una consulta a la bd para recargar los datos.\n       dispatch({type:type,data:formData});\n    })\n   .catch(function(error) { console.error(\"Error al crear documento \", error); });\n}\n\n//Eliminar un registro o documento en una collection\nfunction dbDelete(dispatch, type, colletion, component, documentId){\n    db.collection(colletion).doc(documentId).delete().then(function() {\n        dispatch(reset(component));\n        dispatch({type:type,data:documentId});\n    }).catch(function(error) {console.error(\"Error removing document: \", error);});\n}\n\n//Actualizar un registro\nfunction dbUpdate(dispatch, type, colletion, component, e){\n    \n}\n\nconst DbCrud = {dbFindRegister, dbFindColletion, dbCreate, dbDelete}\n\nexport default DbCrud;"]},"metadata":{},"sourceType":"module"}