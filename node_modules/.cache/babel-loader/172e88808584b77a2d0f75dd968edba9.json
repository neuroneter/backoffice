{"ast":null,"code":"import firebase from './Firebase.js';\nimport { reset } from 'redux-form';\nvar db = firebase.firestore();\nvar UrlServerless = \"https://us-central1-serverless-278902.cloudfunctions.net/serverless\";\nvar UrlLocal = \"http://localhost:5555\";\n\nfunction dbMLoad() {\n  var colletion = \"orders\";\n  var service = \"find\";\n  var queryUrl = UrlServerless + \"/\" + colletion + \"/\" + service;\n  var data = {\n    \"pag\": \"1\",\n    \"limit\": \"3\",\n    \"filFile\": \"customer\",\n    \"filValue\": \"s\",\n    \"sorts\": [{\n      \"file\": \"customer\",\n      \"value\": 1\n    }, {\n      \"file\": \"skuName\",\n      \"value\": -1\n    }]\n  };\n  var requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"method\": \"POST\"\n    },\n    body: data\n  };\n  var myHeaders = new Headers({\n    \"method\": \"POST\",\n    \"contentType\": \"application/json\"\n  });\n  var miInit = {\n    method: 'POST',\n    headers: myHeaders,\n    mode: 'no-cors',\n    cache: 'default',\n    body: data\n  }; // Where we're fetching data from\n\n  fetch(queryUrl, requestOptions).then(function (response) {\n    return response.json();\n  }).then(function (data) {\n    console.log(\"Respuesta \" + data);\n  }) // Catch any errors we hit and update the app\n  .catch(function (error) {\n    console.log(\"Error cargando datos \" + error);\n  });\n} //Busca un registro puntual utilizando una llave o value fijo para en un campo o file \n\n\nfunction dbFindRegister(dispatch, type, colletion, file, value) {\n  db.collection(colletion).where(file, \"==\", value).get().then(function (snapshot) {\n    snapshot.forEach(function (doc) {\n      dispatch({\n        type: type,\n        data: doc.data()\n      });\n    });\n  }).catch(function (error) {\n    console.log(\"Error getting documents: \" + error);\n  });\n} //Recupera todos los valores de una Collection de datos \n\n\nfunction dbFindColletion(dispatch, type, colletion) {\n  dbMLoad(); //Hacemos la llamada a la bd para buscar todos los datos de una collection\n\n  db.collection(colletion).get().then(function (snapshot) {\n    dispatch({\n      type: type,\n      data: snapshot\n    });\n  }).catch(function (error) {\n    console.log(\"Error getting documents: \" + error);\n  });\n}\n\nfunction objDb(e) {\n  //Recuperamos todos los objetos que tienen una etiqueta refs\n  var dateRef = e.refs;\n  var formData = {};\n  var latitude = 0;\n  var longitude = 0;\n  var valorTmp = ''; //Recorremos el array con todas las etiquetas refs\n\n  for (var field in dateRef) {\n    //Recuperamos el valor que tiene el objeto del formulario \n    valorTmp = document.getElementById(field).value; //Como los tipos Geopoint se component de dos datos tenemos un if que nos permite identificarlos para posteriormente construir el array que correponde a la cordenada\n\n    if (dateRef[field].props.format == 'latitude') latitude = parseFloat(valorTmp);else if (dateRef[field].props.format == 'longitude') longitude = parseFloat(valorTmp);else formData[field] = valorTmp; //Al utilizar maskaras en input utilizamos el caracter * que rechena valores blancos por lo que antes de almacenar \n    //en la bd tenemos que retirar estos caracteres\n  }\n\n  if (latitude != 0 && longitude != 0) formData[\"geopoint\"] = new firebase.firestore.GeoPoint(latitude, longitude);\n  return formData;\n} //Crea un nuevo registro en la base de datos \n\n\nfunction dbCreate(dispatch, type, colletion, component, e) {\n  var formData = objDb(e); //Procedemos ha ingresar el valor en la collection, utilizando como documento id un valor autogenerado \n  //dejamos que Firebase sea quien lo genere \n\n  db.collection(colletion).add(formData).then(function (docRef) {\n    //agregamos al objeto nuevo el valor retornado de identificación \n    formData[\"documentId\"] = docRef.id; //Para tener los listados actualizados reseteamos el componente listado\n\n    dispatch(reset(component)); //Ahora procedemos a llamar la funcion dispatcher quien se encargara de adicionar al state el nuevo objeto \n    //sin tener que realizar una consulta a la bd para recargar los datos.\n\n    dispatch({\n      type: type,\n      data: formData\n    });\n  }).catch(function (error) {\n    console.error(\"Error al crear documento \", error);\n  });\n} //Eliminar un registro o documento en una collection\n\n\nfunction dbDelete(dispatch, type, colletion, component, documentId) {\n  db.collection(colletion).doc(documentId).delete().then(function () {\n    dispatch(reset(component));\n    dispatch({\n      type: type,\n      data: documentId\n    });\n  }).catch(function (error) {\n    console.error(\"Error removing document: \", error);\n  });\n} //Actualizar un registro\n\n\nfunction dbUpdate(dispatch, type, colletion, component, e, documentId) {\n  var formData = objDb(e);\n  formData[\"documentId\"] = documentId; // To update age and favorite color:\n\n  db.collection(colletion).doc(documentId).update(formData).then(function () {\n    dispatch(reset(component));\n    dispatch({\n      type: type,\n      data: formData\n    });\n  });\n} //Actualizar el campo de un registro \n\n\nfunction dbEditFile(dispatch, type, colletion, component, documentId, fileEdit, newFileEdit) {\n  var formData = {};\n  formData[fileEdit] = newFileEdit;\n  var coll = db.collection(colletion).doc(documentId).update(formData).then(function () {\n    dispatch(reset(component));\n    dispatch({\n      type: type,\n      data: formData\n    });\n  });\n}\n\nvar DbCrud = {\n  dbFindRegister: dbFindRegister,\n  dbFindColletion: dbFindColletion,\n  dbCreate: dbCreate,\n  dbDelete: dbDelete,\n  dbUpdate: dbUpdate,\n  dbEditFile: dbEditFile\n};\nexport default DbCrud;","map":{"version":3,"sources":["/Users/danielobedortegahernandez/iCloud/Documents/GitHub/bobSeller/src/Pojo/DbCrud.js"],"names":["firebase","reset","db","firestore","UrlServerless","UrlLocal","dbMLoad","colletion","service","queryUrl","data","requestOptions","method","headers","body","myHeaders","Headers","miInit","mode","cache","fetch","then","response","json","console","log","catch","error","dbFindRegister","dispatch","type","file","value","collection","where","get","snapshot","forEach","doc","dbFindColletion","objDb","e","dateRef","refs","formData","latitude","longitude","valorTmp","field","document","getElementById","props","format","parseFloat","GeoPoint","dbCreate","component","add","docRef","id","dbDelete","documentId","delete","dbUpdate","update","dbEditFile","fileEdit","newFileEdit","coll","DbCrud"],"mappings":"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","sourcesContent":["import firebase from './Firebase.js';\nimport { reset } from 'redux-form';\nlet db = firebase.firestore();\n\nvar UrlServerless = \"https://us-central1-serverless-278902.cloudfunctions.net/serverless\";\nvar UrlLocal = \"http://localhost:5555\";\n\nfunction dbMLoad(){\n    \n    var colletion = \"orders\";\n    var service = \"find\"\n    var queryUrl = UrlServerless+\"/\"+colletion+\"/\"+service;\n    var data = {\n        \"pag\":\"1\",\n        \"limit\":\"3\",\n        \"filFile\":\"customer\",\n        \"filValue\": \"s\",\n        \"sorts\":[\n          {\n            \"file\":\"customer\",\n            \"value\":1\n          },{\n            \"file\":\"skuName\",\n            \"value\":-1\n          }\n        ]\n    }\n\n    const requestOptions = {\n        method: \"POST\",\n        headers: { \n            \"Content-Type\": \"application/json\",\n            \"method\" : \"POST\"\n        },\n        body: data\n    };\n\n    var myHeaders = new Headers({\n        \"method\" : \"POST\",\n        \"contentType\" : \"application/json\"\n    });\n\n    var miInit = { \n        method: 'POST',\n        headers: myHeaders,\n        mode: 'no-cors',\n        cache: 'default',\n        body: data\n    };\n\n\n    // Where we're fetching data from\n    fetch(queryUrl,requestOptions)\n    .then(response => response.json())\n    .then(data => {\n        console.log(\"Respuesta \"+data);   \n    })\n    // Catch any errors we hit and update the app\n    .catch(function (error) {\n        console.log(\"Error cargando datos \" + error);\n    });\n        \n}\n\n//Busca un registro puntual utilizando una llave o value fijo para en un campo o file \nfunction dbFindRegister(dispatch, type, colletion, file, value) {\n    db.collection(colletion)\n        .where(file, \"==\", value).get()\n        .then(function (snapshot) {\n            snapshot.forEach(function (doc) {\n                dispatch({ type: type, data: doc.data() })\n            });\n        })\n        .catch(function (error) {\n            console.log(\"Error getting documents: \" + error);\n        });\n}\n\n//Recupera todos los valores de una Collection de datos \nfunction dbFindColletion(dispatch, type, colletion) {\n    dbMLoad();\n    //Hacemos la llamada a la bd para buscar todos los datos de una collection\n    db.collection(colletion)\n        .get()\n        .then(function (snapshot) {\n            dispatch({ type: type, data: snapshot });\n        })\n        .catch(function (error) {\n            console.log(\"Error getting documents: \" + error);\n        });\n}\n\nfunction objDb(e){\n     //Recuperamos todos los objetos que tienen una etiqueta refs\n     const dateRef = e.refs;\n     const formData = {};\n     var latitude = 0;\n     var longitude = 0;\n     var valorTmp = '';\n     //Recorremos el array con todas las etiquetas refs\n     for (const field in dateRef) {\n         //Recuperamos el valor que tiene el objeto del formulario \n         valorTmp = document.getElementById(field).value;\n         //Como los tipos Geopoint se component de dos datos tenemos un if que nos permite identificarlos para posteriormente construir el array que correponde a la cordenada\n         if (dateRef[field].props.format == 'latitude') latitude = parseFloat(valorTmp);\n         else if (dateRef[field].props.format == 'longitude') longitude = parseFloat(valorTmp);\n         else formData[field] = valorTmp;\n         //Al utilizar maskaras en input utilizamos el caracter * que rechena valores blancos por lo que antes de almacenar \n         //en la bd tenemos que retirar estos caracteres\n     }\n \n     if (latitude != 0 && longitude != 0) formData[\"geopoint\"] = new firebase.firestore.GeoPoint(latitude, longitude);\n     return formData;\n}\n\n//Crea un nuevo registro en la base de datos \nfunction dbCreate(dispatch, type, colletion, component, e) {\n    const formData = objDb(e);\n    //Procedemos ha ingresar el valor en la collection, utilizando como documento id un valor autogenerado \n    //dejamos que Firebase sea quien lo genere \n    db.collection(colletion).add(formData)\n        .then(function (docRef) {\n            //agregamos al objeto nuevo el valor retornado de identificación \n            formData[\"documentId\"] = docRef.id;\n            //Para tener los listados actualizados reseteamos el componente listado\n            dispatch(reset(component));\n            //Ahora procedemos a llamar la funcion dispatcher quien se encargara de adicionar al state el nuevo objeto \n            //sin tener que realizar una consulta a la bd para recargar los datos.\n            dispatch({ type: type, data: formData });\n        })\n        .catch(function (error) { console.error(\"Error al crear documento \", error); });\n}\n\n//Eliminar un registro o documento en una collection\nfunction dbDelete(dispatch, type, colletion, component, documentId) {\n    db.collection(colletion).doc(documentId).delete().then(function () {\n        dispatch(reset(component));\n        dispatch({ type: type, data: documentId });\n    }).catch(function (error) { console.error(\"Error removing document: \", error); });\n}\n\n//Actualizar un registro\nfunction dbUpdate(dispatch, type, colletion, component, e, documentId) {\n    const formData = objDb(e);\n    formData[\"documentId\"] = documentId;\n    // To update age and favorite color:\n    db.collection(colletion).doc(documentId).update(formData)\n    .then(function () {\n        dispatch(reset(component));\n        dispatch({ type: type, data: formData });\n    });\n\n}\n\n//Actualizar el campo de un registro \nfunction dbEditFile(dispatch, type, colletion, component, documentId, fileEdit, newFileEdit){\n    const formData = {};\n    formData[fileEdit] = newFileEdit;\n    var coll = db.collection(colletion).doc(documentId)\n    .update(formData)\n    .then(function () {\n        dispatch(reset(component));\n        dispatch({ type: type, data: formData });\n    });\n}\n\nconst DbCrud = { dbFindRegister, dbFindColletion, dbCreate, dbDelete, dbUpdate, dbEditFile }\n\nexport default DbCrud;"]},"metadata":{},"sourceType":"module"}