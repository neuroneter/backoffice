{"map":"{\"version\":3,\"sources\":[\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-loader/lib/index.js??ref--6-oneOf-2!/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/react-shallow-equal/dist/react-shallow-equal.esm.js\",\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-loader/lib/index.js??ref--6-oneOf-2!/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/react-text-mask-hoc/dist/react-text-mask-hoc.esm.js\",\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-loader/lib/index.js??ref--6-oneOf-2!/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/style-equal/index.js\"],\"names\":[\"_typeof\",\"Symbol\",\"iterator\",\"obj\",\"constructor\",\"prototype\",\"type\",\"value\",\"Array\",\"isArray\",\"propsEqual\",\"a\",\"b\",\"options\",\"arguments\",\"length\",\"undefined\",\"aKeys\",\"Object\",\"keys\",\"aCount\",\"bCount\",\"i\",\"l\",\"key\",\"ignore\",\"indexOf\",\"bKeys\",\"_i\",\"_l\",\"_key\",\"style_equal_default\",\"style\",\"elementsEqual\",\"typeOfA\",\"ref\",\"props\",\"children\",\"_extends\",\"assign\",\"target\",\"source\",\"hasOwnProperty\",\"call\",\"apply\",\"this\",\"_objectWithoutPropertiesLoose\",\"excluded\",\"sourceKeys\",\"__webpack_require__\",\"d\",\"__webpack_exports__\",\"react_text_mask_hoc_esm_TextMask\",\"react_text_mask_hoc_esm_InputAdapter\",\"defaultArray\",\"emptyString\",\"placeholderChar\",\"strFunction\",\"emptyArray\",\"convertMaskToPlaceholder\",\"mask\",\"placeholderChar$$1\",\"Error\",\"concat\",\"JSON\",\"stringify\",\"map\",\"char\",\"RegExp\",\"join\",\"isString\",\"String\",\"strCaretTrap\",\"processCaretTraps\",\"indexOfCaretTrap\",\"indexes\",\"push\",\"splice\",\"maskWithoutCaretTraps\",\"emptyArray$1\",\"emptyString$1\",\"getSafeRawValue\",\"inputValue\",\"isNaN\",\"react_text_mask_hoc_esm_TextMaskTransformer\",\"TextMaskTransformer\",\"classCallCheck\",\"previousConformedValue\",\"previousPlaceholder\",\"createClass\",\"_ref2\",\"placeholder\",\"rawValue\",\"currentCaretPosition\",\"caretPosition\",\"providedMask\",\"guide\",\"pipe\",\"_ref2$placeholderChar\",\"_ref2$keepCharPositio\",\"keepCharPositions\",\"_ref2$showMask\",\"showMask\",\"caretTrapIndexes\",\"safeRawValue\",\"_processCaretTraps\",\"conformToMaskConfig\",\"conformedValue\",\"config\",\"_config$guide\",\"_config$previousConfo\",\"_config$placeholderCh\",\"_config$placeholder\",\"suppressGuide\",\"rawValueLength\",\"previousConformedValueLength\",\"placeholderLength\",\"maskLength\",\"editDistance\",\"isAddition\",\"indexOfFirstChange\",\"indexOfLastChange\",\"Math\",\"abs\",\"compensatingPlaceholderChars\",\"slice\",\"rawValueArr\",\"split\",\"isNew\",\"_i4\",\"someCharsRejected\",\"placeholderLoop\",\"_i5\",\"charInPlaceholder\",\"_rawValueArr$shift\",\"shift\",\"rawValueChar\",\"test\",\"rawValueArrLength\",\"indexOfNextAvailablePlaceholderChar\",\"_i6\",\"charData\",\"substr\",\"indexOfLastFilledPlaceholderChar\",\"_i7\",\"meta\",\"conformToMask\",\"piped\",\"pipeResults\",\"rejected\",\"finalConformedValue\",\"adjustedCaretPosition\",\"_ref\",\"_ref$previousConforme\",\"_ref$previousPlacehol\",\"_ref$currentCaretPosi\",\"_ref$indexesOfPipedCh\",\"indexesOfPipedChars\",\"_ref$caretTrapIndexes\",\"conformedValueLength\",\"editLength\",\"trackRightCharacter\",\"targetChar\",\"startingSearchIndex\",\"normalizedConformedValue\",\"toLowerCase\",\"intersection\",\"filter\",\"previousLeftMaskChars\",\"masklengthChanged\",\"targetIsMaskMovingLeft\",\"countTargetCharInPipedChars\",\"index\",\"countTargetCharInIntersection\",\"requiredNumberOfMatches\",\"numberOfEncounteredMatches\",\"lastPlaceholderChar\",\"_i2\",\"_i3\",\"adjustCaretPosition\",\"inputElementValue\",\"_React$PureComponent\",\"TextMask\",\"context\",\"_this\",\"possibleConstructorReturn\",\"getPrototypeOf\",\"_update\",\"bind\",\"assertThisInitialized\",\"_getRef\",\"_onChange\",\"component\",\"textMaskTransformer\",\"nextUpdate\",\"state\",\"inherits\",\"nextProps\",\"isControlled\",\"setState\",\"update\",\"comp\",\"componentRef\",\"event\",\"_this2\",\"text\",\"onChange\",\"forceUpdate\",\"input\",\"focus\",\"blur\",\"_this$props\",\"Component\",\"rest\",\"react_default\",\"createElement\",\"get\",\"PureComponent\",\"defaultProps\",\"isAndroid\",\"navigator\",\"userAgent\",\"isDocument\",\"document\",\"_React$PureComponent2\",\"InputAdapter\",\"_this3\",\"_setCaretPosition\",\"persist\",\"_this4\",\"activeElement\",\"setTimeout\",\"setSelectionRange\",\"selectionEnd\",\"transformEntryEqual\",\"k\",\"transformEqual\",\"module\",\"exports\",\"styleEqual\",\"shallowObjectEquals\",\"j\"],\"mappings\":\"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\",\"sourcesContent\":[\"import stylesEqual from 'style-equal';\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) {\\n  return typeof obj;\\n} : function (obj) {\\n  return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n};\\n/* eslint-disable import/prefer-default-export */\\n\\n\\nfunction type(value) {\\n  if (value === null) return 'null';\\n  if (Array.isArray(value)) return 'array';\\n  return typeof value === 'undefined' ? 'undefined' : _typeof(value);\\n}\\n\\nfunction elementsEqual(a, b) {\\n  var typeOfA = type(a);\\n  if (typeOfA !== type(b)) return false;\\n\\n  switch (typeOfA) {\\n    case 'array':\\n      if (a.length !== b.length) return false;\\n\\n      for (var i = 0; i < a.length; i++) {\\n        if (!elementsEqual(a[i], b[i])) return false;\\n      }\\n\\n      return true;\\n\\n    case 'object':\\n      if (a.type !== b.type) return false;\\n      if (a.key !== b.key) return false;\\n      if (a.ref !== b.ref) return false;\\n      return propsEqual(a.props, b.props);\\n    // eslint-disable-line no-use-before-define\\n\\n    default:\\n      return a === b;\\n  }\\n}\\n\\nfunction propsEqual(a, b) {\\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\\n  var aKeys = Object.keys(a);\\n  var aCount = 0;\\n  var bCount = 0;\\n\\n  for (var i = 0, l = aKeys.length; i < l; i++) {\\n    var key = aKeys[i];\\n\\n    if (!options.ignore || options.ignore.indexOf(key) === -1) {\\n      // Compare `style` and `children` props later\\n      if (key !== 'style' && key !== 'children' && a[key] !== b[key]) return false;\\n      aCount += 1;\\n    }\\n  }\\n\\n  var bKeys = Object.keys(b);\\n\\n  for (var _i = 0, _l = bKeys.length; _i < _l; _i++) {\\n    var _key = bKeys[_i];\\n\\n    if (!options.ignore || options.ignore.indexOf(_key) === -1) {\\n      bCount += 1;\\n    }\\n  }\\n\\n  if (aCount !== bCount) return false; // NOTE: Kind of risky, but I'm assuming that a `style` prop is a React Native style,\\n  // and using the `styleEqual` algorithm here.\\n\\n  if (!stylesEqual(a.style, b.style)) return false; // Compare children last\\n\\n  return elementsEqual(a.children, b.children);\\n}\\n\\nexport { stylesEqual, propsEqual, elementsEqual };\",\"import _possibleConstructorReturn from \\\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\\\";\\nimport _getPrototypeOf from \\\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\\\";\\nimport _inherits from \\\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\\\";\\nimport _assertThisInitialized from \\\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\\\";\\nimport _classCallCheck from \\\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\\\";\\nimport _createClass from \\\"/Users/danielobedortegahernandez/iCloud/Documents/GitHub/backoffice/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\\\";\\nimport React from 'react';\\nimport { propsEqual } from 'react-shallow-equal';\\n\\nfunction _extends() {\\n  _extends = Object.assign || function (target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i];\\n\\n      for (var key in source) {\\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\\n          target[key] = source[key];\\n        }\\n      }\\n    }\\n\\n    return target;\\n  };\\n\\n  return _extends.apply(this, arguments);\\n}\\n\\nfunction _objectWithoutPropertiesLoose(source, excluded) {\\n  if (source == null) return {};\\n  var target = {};\\n  var sourceKeys = Object.keys(source);\\n  var key, i;\\n\\n  for (i = 0; i < sourceKeys.length; i++) {\\n    key = sourceKeys[i];\\n    if (excluded.indexOf(key) >= 0) continue;\\n    target[key] = source[key];\\n  }\\n\\n  return target;\\n}\\n\\nvar defaultArray = [];\\nvar emptyString = '';\\n\\nfunction adjustCaretPosition(_ref) {\\n  var _ref$previousConforme = _ref.previousConformedValue,\\n      previousConformedValue = _ref$previousConforme === void 0 ? emptyString : _ref$previousConforme,\\n      _ref$previousPlacehol = _ref.previousPlaceholder,\\n      previousPlaceholder = _ref$previousPlacehol === void 0 ? emptyString : _ref$previousPlacehol,\\n      _ref$currentCaretPosi = _ref.currentCaretPosition,\\n      currentCaretPosition = _ref$currentCaretPosi === void 0 ? 0 : _ref$currentCaretPosi,\\n      conformedValue = _ref.conformedValue,\\n      rawValue = _ref.rawValue,\\n      placeholderChar = _ref.placeholderChar,\\n      placeholder = _ref.placeholder,\\n      _ref$indexesOfPipedCh = _ref.indexesOfPipedChars,\\n      indexesOfPipedChars = _ref$indexesOfPipedCh === void 0 ? defaultArray : _ref$indexesOfPipedCh,\\n      _ref$caretTrapIndexes = _ref.caretTrapIndexes,\\n      caretTrapIndexes = _ref$caretTrapIndexes === void 0 ? defaultArray : _ref$caretTrapIndexes;\\n\\n  if (currentCaretPosition === 0 || !rawValue.length) {\\n    return 0;\\n  } // Store lengths for faster performance?\\n\\n\\n  var rawValueLength = rawValue.length;\\n  var previousConformedValueLength = previousConformedValue.length;\\n  var placeholderLength = placeholder.length;\\n  var conformedValueLength = conformedValue.length; // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\\n  // we know the user in this instance pasted two characters\\n\\n  var editLength = rawValueLength - previousConformedValueLength; // If the edit length is positive, that means the user is adding characters, not deleting.\\n\\n  var isAddition = editLength > 0; // This is the first raw value the user entered that needs to be conformed to mask\\n\\n  var isFirstRawValue = previousConformedValueLength === 0; // A partial multi-character edit happens when the user makes a partial selection in their\\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\\n  // selecting the first 3 digits and pressing backspace.\\n  //\\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\\n  // key.\\n\\n  var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue; // This algorithm doesn't support all cases of multi-character edits, so we just return\\n  // the current caret position.\\n  //\\n  // This works fine for most cases.\\n\\n  if (isPartialMultiCharEdit) {\\n    return currentCaretPosition;\\n  } // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\\n  // same as the original `previousConformedValue`. We handle this case differently for caret\\n  // positioning.\\n\\n\\n  var possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\\n  var startingSearchIndex = 0;\\n  var trackRightCharacter;\\n  var targetChar;\\n\\n  if (possiblyHasRejectedChar) {\\n    startingSearchIndex = currentCaretPosition - editLength;\\n  } else {\\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\\n    // has been conformed, and then see if we can find that same spot in the conformed input.\\n    //\\n    // We do that by seeing what character lies immediately before the caret, and then look for that\\n    // same character in the conformed input and place the caret there.\\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\\n    // conformed input wouldn't matter.\\n    var normalizedConformedValue = conformedValue.toLowerCase();\\n    var normalizedRawValue = rawValue.toLowerCase(); // Then we take all characters that come before where the caret currently is.\\n\\n    var leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString); // Now we find all the characters in the left half that exist in the conformed input\\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\\n\\n    var intersection = leftHalfChars.filter(function (char) {\\n      return normalizedConformedValue.indexOf(char) !== -1;\\n    }); // The last character in the intersection is the character we want to look for in the conformed\\n    // value and the one we want to adjust the caret close to\\n\\n    targetChar = intersection[intersection.length - 1]; // Calculate the number of mask characters in the previous placeholder\\n    // from the start of the string up to the place where the caret is\\n\\n    var previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\\n      return char !== placeholderChar;\\n    }).length; // Calculate the number of mask characters in the current placeholder\\n    // from the start of the string up to the place where the caret is\\n\\n    var leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\\n      return char !== placeholderChar;\\n    }).length; // Has the number of mask characters up to the caret changed?\\n\\n    var masklengthChanged = leftMaskChars !== previousLeftMaskChars; // Detect if `targetChar` is a mask character and has moved to the left\\n\\n    var targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]; // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\\n    // if we are not at the end of the string.\\n    // In this case, change tracking strategy and track the character to the right of the caret.\\n\\n    if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\\n      trackRightCharacter = true;\\n      targetChar = rawValue[currentCaretPosition];\\n    } // It is possible that `targetChar` will appear multiple times in the conformed value.\\n    // We need to know not to select a character that looks like our target character from the placeholder or\\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\\n    // characters that match our target character.\\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\\n    // our `targetChar`, we don't select a piped char by mistake\\n\\n\\n    var pipedChars = indexesOfPipedChars.map(function (index) {\\n      return normalizedConformedValue[index];\\n    }); // We need to know how many times the `targetChar` occurs in the piped characters.\\n\\n    var countTargetCharInPipedChars = pipedChars.filter(function (char) {\\n      return char === targetChar;\\n    }).length; // We need to know how many times it occurs in the intersection\\n\\n    var countTargetCharInIntersection = intersection.filter(function (char) {\\n      return char === targetChar;\\n    }).length; // We need to know if the placeholder contains characters that look like\\n    // our `targetChar`, so we don't select one of those by mistake.\\n\\n    var countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter(function (char, index) {\\n      return (// Check if `char` is the same as our `targetChar`, so we account for it\\n        char === targetChar && // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\\n        // index because if they are equal, that means we are already counting those characters in\\n        // `countTargetCharInIntersection`\\n        rawValue[index] !== char\\n      );\\n    }).length; // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\\n    // for is:\\n\\n    var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + ( // The character to the right of the caret isn't included in `intersection`\\n    // so add one if we are tracking the character to the right\\n    trackRightCharacter ? 1 : 0); // Now we start looking for the location of the `targetChar`.\\n    // We keep looping forward and store the index in every iteration. Once we have encountered\\n    // enough occurrences of the target character, we break out of the loop\\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\\n\\n    var numberOfEncounteredMatches = 0;\\n\\n    for (var i = 0; i < conformedValueLength; i++) {\\n      var conformedValueChar = normalizedConformedValue[i];\\n      startingSearchIndex = i + 1;\\n\\n      if (conformedValueChar === targetChar) {\\n        numberOfEncounteredMatches++;\\n      }\\n\\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\\n        break;\\n      }\\n    }\\n  } // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\\n  // logic is for.\\n  // In case of addition, we fast forward.\\n\\n\\n  if (isAddition) {\\n    // We want to remember the last placeholder character encountered so that if the mask\\n    // contains more characters after the last placeholder character, we don't forward the caret\\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\\n    var lastPlaceholderChar = startingSearchIndex;\\n\\n    for (var _i = startingSearchIndex; _i <= placeholderLength; _i++) {\\n      if (placeholder[_i] === placeholderChar) {\\n        lastPlaceholderChar = _i;\\n      }\\n\\n      if ( // If we're adding, we can position the caret at the next placeholder character.\\n      placeholder[_i] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\\n      caretTrapIndexes.indexOf(_i) !== -1 || // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\\n      _i === placeholderLength) {\\n        return lastPlaceholderChar;\\n      }\\n    }\\n  } else {\\n    // In case of deletion, we rewind.\\n    if (trackRightCharacter) {\\n      // Searching for the character that was to the right of the caret\\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\\n      for (var _i2 = startingSearchIndex - 1; _i2 >= 0; _i2--) {\\n        // If tracking the character to the right of the cursor, we move to the left until\\n        // we found the character and then place the caret right before it\\n        if ( // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\\n        // to the right of the caret\\n        conformedValue[_i2] === targetChar || // If a caret trap was set by a mask function, we need to stop at the trap.\\n        caretTrapIndexes.indexOf(_i2) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\\n        // Let's put the caret there.\\n        _i2 === 0) {\\n          return _i2;\\n        }\\n      }\\n    } else {\\n      // Searching for the first placeholder or caret trap to the left\\n      for (var _i3 = startingSearchIndex; _i3 >= 0; _i3--) {\\n        // If we're deleting, we stop the caret right before the placeholder character.\\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\\n        // right after the first `6`\\n        if ( // If we're deleting, we can position the caret right before the placeholder character\\n        placeholder[_i3 - 1] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\\n        caretTrapIndexes.indexOf(_i3) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\\n        // Let's put the caret there.\\n        _i3 === 0) {\\n          return _i3;\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nvar placeholderChar = '_';\\nvar strFunction = 'function';\\nvar emptyArray = [];\\n\\nfunction convertMaskToPlaceholder() {\\n  var mask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyArray;\\n  var placeholderChar$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeholderChar;\\n\\n  if (!isArray(mask)) {\\n    throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\\n  }\\n\\n  if (mask.indexOf(placeholderChar$$1) !== -1) {\\n    throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\\\n\\\\n' + \\\"The placeholder character that was received is: \\\".concat(JSON.stringify(placeholderChar$$1), \\\"\\\\n\\\\n\\\") + \\\"The mask that was received is: \\\".concat(JSON.stringify(mask)));\\n  }\\n\\n  return mask.map(function (char) {\\n    return char instanceof RegExp ? placeholderChar$$1 : char;\\n  }).join('');\\n}\\n\\nfunction isArray(value) {\\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\\n}\\n\\nfunction isString(value) {\\n  return typeof value === 'string' || value instanceof String;\\n}\\n\\nfunction isNumber(value) {\\n  return typeof value === 'number' && value.length === undefined && !isNaN(value);\\n}\\n\\nvar strCaretTrap = '[]';\\n\\nfunction processCaretTraps(mask) {\\n  var indexes = [];\\n  var indexOfCaretTrap;\\n\\n  while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\\n    // eslint-disable-line\\n    indexes.push(indexOfCaretTrap);\\n    mask.splice(indexOfCaretTrap, 1);\\n  }\\n\\n  return {\\n    maskWithoutCaretTraps: mask,\\n    indexes: indexes\\n  };\\n}\\n\\nvar emptyArray$1 = [];\\nvar emptyString$1 = '';\\n\\nfunction conformToMask() {\\n  var rawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyString$1;\\n  var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyArray$1;\\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\\n\\n  if (!isArray(mask)) {\\n    // If someone passes a function as the mask property, we should call the\\n    // function to get the mask array - Normally this is handled by the\\n    // `createTextMaskInputElement:update` function - this allows mask functions\\n    // to be used directly with `conformToMask`\\n    if (typeof mask === strFunction) {\\n      // call the mask function to get the mask array\\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\\n\\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\\n    } else {\\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\\n    }\\n  } // These configurations tell us how to conform the mask\\n\\n\\n  var _config$guide = config.guide,\\n      guide = _config$guide === void 0 ? true : _config$guide,\\n      _config$previousConfo = config.previousConformedValue,\\n      previousConformedValue = _config$previousConfo === void 0 ? emptyString$1 : _config$previousConfo,\\n      _config$placeholderCh = config.placeholderChar,\\n      placeholderChar$$1 = _config$placeholderCh === void 0 ? placeholderChar : _config$placeholderCh,\\n      _config$placeholder = config.placeholder,\\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar$$1) : _config$placeholder,\\n      currentCaretPosition = config.currentCaretPosition,\\n      keepCharPositions = config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\\n\\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\\n\\n  var rawValueLength = rawValue.length;\\n  var previousConformedValueLength = previousConformedValue.length;\\n  var placeholderLength = placeholder.length;\\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\\n\\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\\n\\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\\n\\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\\n\\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\\n  // __3, not _3_ (default behavior)\\n  //\\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\\n  // character positions for the case of addition is further down since it is handled differently.)\\n  // To do this, we want to compensate for all characters that were deleted\\n\\n  if (keepCharPositions === true && !isAddition) {\\n    // We will be storing the new placeholder characters in this variable.\\n    var compensatingPlaceholderChars = emptyString$1; // For every character that was deleted from a placeholder position, we add a placeholder char\\n\\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\\n      if (placeholder[i] === placeholderChar$$1) {\\n        compensatingPlaceholderChars += placeholderChar$$1;\\n      }\\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\\n    // in their positions.\\n\\n\\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\\n  // to work if it is configured to keep character positions.\\n\\n\\n  var rawValueArr = rawValue.split(emptyString$1).map(function (char, i) {\\n    return {\\n      char: char,\\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\\n    };\\n  }); // The loop below removes masking characters from user input. For example, for mask\\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\\n  // then would lay `234` on top of the available placeholder positions in the mask.\\n\\n  for (var _i4 = rawValueLength - 1; _i4 >= 0; _i4--) {\\n    var char = rawValueArr[_i4].char;\\n\\n    if (char !== placeholderChar$$1) {\\n      var shouldOffset = _i4 >= indexOfFirstChange && previousConformedValueLength === maskLength;\\n\\n      if (char === placeholder[shouldOffset ? _i4 - editDistance : _i4]) {\\n        rawValueArr.splice(_i4, 1);\\n      }\\n    }\\n  } // This is the variable that we will be filling with characters as we figure them out\\n  // in the algorithm below\\n\\n\\n  var conformedValue = emptyString$1;\\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\\n\\n  placeholderLoop: for (var _i5 = 0; _i5 < placeholderLength; _i5++) {\\n    var charInPlaceholder = placeholder[_i5]; // We see one. Let's find out what we can put in it.\\n\\n    if (charInPlaceholder === placeholderChar$$1) {\\n      // But before that, do we actually have any user characters that need a place?\\n      if (rawValueArr.length > 0) {\\n        // We will keep chipping away at user input until either we run out of characters\\n        // or we find at least one character that we can map.\\n        while (rawValueArr.length > 0) {\\n          // Let's retrieve the first user character in the queue of characters we have left\\n          var _rawValueArr$shift = rawValueArr.shift(),\\n              rawValueChar = _rawValueArr$shift.char,\\n              isNew = _rawValueArr$shift.isNew; // If the character we got from the user input is a placeholder character (which happens\\n          // regularly because user input could be something like (540) 90_-____, which includes\\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\\n          // then we map this placeholder character to the current spot in the placeholder\\n\\n\\n          if (rawValueChar === placeholderChar$$1 && suppressGuide !== true) {\\n            conformedValue += placeholderChar$$1; // And we go to find the next placeholder character that needs filling\\n\\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\\n            // if the current position in the mask can accept it.\\n          } else if (mask[_i5].test(rawValueChar)) {\\n            // we map the character differently based on whether we are keeping character positions or not.\\n            // If any of the conditions below are met, we simply map the raw value character to the\\n            // placeholder position.\\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString$1 || guide === false || !isAddition) {\\n              conformedValue += rawValueChar;\\n            } else {\\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\\n              //\\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\\n              var rawValueArrLength = rawValueArr.length;\\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\\n\\n              for (var _i6 = 0; _i6 < rawValueArrLength; _i6++) {\\n                var charData = rawValueArr[_i6];\\n\\n                if (charData.char !== placeholderChar$$1 && charData.isNew === false) {\\n                  break;\\n                }\\n\\n                if (charData.char === placeholderChar$$1) {\\n                  indexOfNextAvailablePlaceholderChar = _i6;\\n                  break;\\n                }\\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\\n              // We can map it. And to keep the character positions, we remove the placeholder character\\n              // from the remaining characters\\n\\n\\n              if (indexOfNextAvailablePlaceholderChar !== null) {\\n                conformedValue += rawValueChar;\\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\\n                // discard it.\\n              } else {\\n                _i5--;\\n              }\\n            } // Since we've mapped this placeholder position. We move on to the next one.\\n\\n\\n            continue placeholderLoop;\\n          } else {\\n            someCharsRejected = true;\\n          }\\n        }\\n      } // We reach this point when we've mapped all the user input characters to placeholder\\n      // positions in the mask. In *guide* mode, we append the left over characters in the\\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\\n      //\\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\\n\\n\\n      if (suppressGuide === false) {\\n        conformedValue += placeholder.substr(_i5, placeholderLength);\\n      } // And we break\\n\\n\\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\\n      // with user input. So we just map it to the final output\\n    } else {\\n      conformedValue += charInPlaceholder;\\n    }\\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\\n  //\\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\\n  // That's why the logic below finds the last filled placeholder character, and removes everything\\n  // from that point on.\\n\\n\\n  if (suppressGuide && isAddition === false) {\\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\\n\\n    for (var _i7 = 0; _i7 < conformedValue.length; _i7++) {\\n      if (placeholder[_i7] === placeholderChar$$1) {\\n        indexOfLastFilledPlaceholderChar = _i7;\\n      }\\n    }\\n\\n    if (indexOfLastFilledPlaceholderChar !== null) {\\n      // We substring from the beginning until the position after the last filled placeholder char.\\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\\n    } else {\\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\\n      // the first character in the mask. So we return an empty string.\\n      conformedValue = emptyString$1;\\n    }\\n  }\\n\\n  return {\\n    conformedValue: conformedValue,\\n    meta: {\\n      someCharsRejected: someCharsRejected\\n    }\\n  };\\n}\\n\\nfunction getSafeRawValue(inputValue) {\\n  if (inputValue == null) return '';\\n  if (isString(inputValue)) return inputValue;\\n  if (isNumber(inputValue)) return String(inputValue);\\n  throw new Error(\\\"The 'value' provided to Text Mask needs to be a string or a number. The value \\\" + \\\"received was:\\\\n\\\\n \\\".concat(JSON.stringify(inputValue)));\\n}\\n\\nvar TextMaskTransformer =\\n/*#__PURE__*/\\nfunction () {\\n  function TextMaskTransformer() {\\n    _classCallCheck(this, TextMaskTransformer);\\n\\n    this.previousConformedValue = undefined;\\n    this.previousPlaceholder = undefined;\\n  }\\n\\n  _createClass(TextMaskTransformer, [{\\n    key: \\\"update\\\",\\n    value: function update(_ref2) {\\n      var rawValue = _ref2.value,\\n          currentCaretPosition = _ref2.caretPosition,\\n          providedMask = _ref2.mask,\\n          guide = _ref2.guide,\\n          pipe = _ref2.pipe,\\n          _ref2$placeholderChar = _ref2.placeholderChar,\\n          placeholderChar$$1 = _ref2$placeholderChar === void 0 ? placeholderChar : _ref2$placeholderChar,\\n          _ref2$keepCharPositio = _ref2.keepCharPositions,\\n          keepCharPositions = _ref2$keepCharPositio === void 0 ? false : _ref2$keepCharPositio,\\n          _ref2$showMask = _ref2.showMask,\\n          showMask = _ref2$showMask === void 0 ? false : _ref2$showMask;\\n\\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\\n      if (rawValue === this.previousConformedValue) {\\n        return null;\\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together.\\n      // If such a `mask` is passed, we destructure it below, so the rest of the code can work normally\\n      // as if a separate `mask` and a `pipe` were passed.\\n\\n\\n      if (providedMask != null && typeof providedMask === 'object' && providedMask.pipe != null && providedMask.mask != null) {\\n        /* eslint-disable no-param-reassign, prefer-destructuring */\\n        pipe = providedMask.pipe;\\n        providedMask = providedMask.mask;\\n        /* eslint-enable */\\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`,\\n      // the placeholder would be `(___)` if the `placeholderChar` is set to `_`.\\n\\n\\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function,\\n      // we will have to call that function to get the mask array.\\n\\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\\n      // correct `placeholder`.\\n\\n      if (Array.isArray(providedMask)) {\\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar$$1);\\n      } // We check the provided `rawValue` before moving further.\\n      // If it's something we can't work with `getSafeRawValue` will throw.\\n\\n\\n      var safeRawValue = getSafeRawValue(rawValue); // In framework components that support reactivity, it's possible to turn off masking by passing\\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\\n\\n      if (providedMask === false) {\\n        return {\\n          value: safeRawValue,\\n          caretPosition: currentCaretPosition\\n        };\\n      }\\n\\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\\n      // Then we also need to get the `placeholder`\\n\\n      if (typeof providedMask === 'function') {\\n        mask = providedMask(safeRawValue, {\\n          currentCaretPosition: currentCaretPosition,\\n          previousConformedValue: this.previousConformedValue,\\n          placeholderChar: placeholderChar$$1\\n        }); // disable masking if `mask` is `false`\\n\\n        if (mask === false) {\\n          return null;\\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\\n        // the indexes of the caret traps.\\n\\n\\n        var _processCaretTraps = processCaretTraps(mask),\\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\\n            indexes = _processCaretTraps.indexes; // The processed mask is what we're interested in\\n\\n\\n        mask = maskWithoutCaretTraps; // And we need to store these indexes because they're needed by `adjustCaretPosition`\\n\\n        caretTrapIndexes = indexes;\\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar$$1); // If the `providedMask` is not a function, we just use it as-is.\\n      } else {\\n        mask = providedMask;\\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\\n\\n\\n      var conformToMaskConfig = {\\n        previousConformedValue: this.previousConformedValue,\\n        guide: guide,\\n        placeholderChar: placeholderChar$$1,\\n        pipe: pipe,\\n        placeholder: placeholder,\\n        currentCaretPosition: currentCaretPosition,\\n        keepCharPositions: keepCharPositions\\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\\n\\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\\n\\n\\n      var piped = typeof pipe === 'function';\\n      var pipeResults = {}; // If `pipe` is a function, we call it.\\n\\n      if (piped) {\\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\\n        pipeResults = pipe(conformedValue, _extends({\\n          rawValue: safeRawValue\\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just\\n        // return `false` to indicate rejection. Or return just a string when there are no piped characters.\\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\\n        // of the code can work with.\\n\\n        if (pipeResults === false) {\\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,\\n          // and set `rejected` to `true`.\\n          pipeResults = {\\n            value: this.previousConformedValue,\\n            rejected: true\\n          };\\n        } else if (isString(pipeResults)) {\\n          pipeResults = {\\n            value: pipeResults\\n          };\\n        }\\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\\n      // returned by `conformToMask`.\\n\\n\\n      var finalConformedValue = piped ? pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\\n      // the caret position. `adjustCaretPosition` will tell us.\\n\\n      var adjustedCaretPosition = adjustCaretPosition({\\n        previousConformedValue: this.previousConformedValue,\\n        previousPlaceholder: this.previousPlaceholder,\\n        conformedValue: finalConformedValue,\\n        placeholder: placeholder,\\n        rawValue: safeRawValue,\\n        currentCaretPosition: currentCaretPosition,\\n        placeholderChar: placeholderChar$$1,\\n        indexesOfPipedChars: pipeResults.indexesOfPipedChars,\\n        caretTrapIndexes: caretTrapIndexes\\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\\n\\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\\n      var emptyValue = showMask ? placeholder : '';\\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\\n      this.previousConformedValue = inputElementValue; // store value for access for next time\\n\\n      this.previousPlaceholder = placeholder;\\n      return {\\n        value: inputElementValue,\\n        caretPosition: adjustedCaretPosition\\n      };\\n    }\\n  }]);\\n\\n  return TextMaskTransformer;\\n}();\\n\\nvar TextMask =\\n/*#__PURE__*/\\nfunction (_React$PureComponent) {\\n  _inherits(TextMask, _React$PureComponent);\\n\\n  function TextMask(props, context) {\\n    var _this;\\n\\n    _classCallCheck(this, TextMask);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextMask).call(this, props, context));\\n    _this._update = _this._update.bind(_assertThisInitialized(_assertThisInitialized(_this)));\\n    _this._getRef = _this._getRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));\\n    _this._onChange = _this._onChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\\n    _this.component = null;\\n    _this.textMaskTransformer = new TextMaskTransformer();\\n    var value = props.value != null ? props.value : '';\\n\\n    var nextUpdate = _this._update(_extends({}, props, {\\n      value: value\\n    }));\\n\\n    if (nextUpdate !== null) {\\n      _this.state = {\\n        value: nextUpdate.value,\\n        caretPosition: nextUpdate.caretPosition\\n      };\\n    } else {\\n      _this.state = {\\n        value: '',\\n        caretPosition: 0\\n      };\\n    }\\n\\n    return _this;\\n  }\\n\\n  _createClass(TextMask, [{\\n    key: \\\"componentWillReceiveProps\\\",\\n    value: function componentWillReceiveProps(nextProps) {\\n      var ignore = [];\\n\\n      if (nextProps.isControlled === false) {\\n        ignore.push('value');\\n      }\\n\\n      if (!propsEqual(this.props, nextProps, {\\n        ignore: ignore\\n      })) {\\n        var value = nextProps.isControlled === true && nextProps.value != null ? nextProps.value : this.state.value;\\n\\n        var nextUpdate = this._update(_extends({}, nextProps, {\\n          value: value\\n        }));\\n\\n        if (nextUpdate !== null) {\\n          this.setState(nextUpdate);\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"_update\\\",\\n    value: function _update(props) {\\n      return this.textMaskTransformer.update({\\n        value: props.value,\\n        caretPosition: this.component != null ? this.component.caretPosition : 0,\\n        mask: props.mask,\\n        guide: props.guide,\\n        pipe: props.pipe,\\n        placeholderChar: props.placeholderChar,\\n        keepCharPositions: props.keepCharPositions,\\n        showMask: props.showMask\\n      });\\n    }\\n  }, {\\n    key: \\\"_getRef\\\",\\n    value: function _getRef(comp) {\\n      if (comp) {\\n        this.props.componentRef(comp);\\n        this.component = comp;\\n      }\\n    }\\n  }, {\\n    key: \\\"_onChange\\\",\\n    value: function _onChange(event) {\\n      var _this2 = this;\\n\\n      if (event) {\\n        var rawValue = typeof event.target === 'object' ? event.target.value : event.text;\\n\\n        var nextUpdate = this._update(_extends({}, this.props, {\\n          value: rawValue\\n        }));\\n\\n        if (nextUpdate !== null) {\\n          this.setState(nextUpdate, function () {\\n            _this2.props.onChange(event, nextUpdate);\\n          });\\n        } else {\\n          this.props.onChange(event, this.state);\\n          this.forceUpdate();\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"focus\\\",\\n    value: function focus() {\\n      if (this.component.input) this.component.input.focus();\\n    }\\n  }, {\\n    key: \\\"blur\\\",\\n    value: function blur() {\\n      if (this.component.input) this.component.input.blur();\\n    }\\n  }, {\\n    key: \\\"render\\\",\\n    value: function render() {\\n      var _this$props = this.props,\\n          Component = _this$props.Component,\\n          rest = _objectWithoutPropertiesLoose(_this$props, [\\\"Component\\\", \\\"value\\\", \\\"isControlled\\\", \\\"mask\\\", \\\"guide\\\", \\\"pipe\\\", \\\"placeholderChar\\\", \\\"keepCharPositions\\\", \\\"showMask\\\", \\\"componentRef\\\", \\\"onChange\\\"]);\\n\\n      return React.createElement(Component, _extends({}, rest, {\\n        value: this.state.value,\\n        caretPosition: this.state.caretPosition,\\n        onChange: this._onChange,\\n        ref: this._getRef\\n      }));\\n    }\\n  }, {\\n    key: \\\"value\\\",\\n    get: function get() {\\n      return this.state.value;\\n    }\\n  }]);\\n\\n  return TextMask;\\n}(React.PureComponent);\\n\\nTextMask.defaultProps = {\\n  value: null,\\n  isControlled: true,\\n  guide: true,\\n  pipe: null,\\n  placeholderChar: '_',\\n  keepCharPositions: false,\\n  showMask: false,\\n  onChange: function onChange() {},\\n  componentRef: function componentRef() {}\\n};\\nvar isAndroid = typeof navigator !== 'undefined' && navigator !== null && /android/i.test(navigator.userAgent);\\nvar isDocument = typeof document !== 'undefined' && document !== null;\\n\\nvar InputAdapter =\\n/*#__PURE__*/\\nfunction (_React$PureComponent2) {\\n  _inherits(InputAdapter, _React$PureComponent2);\\n\\n  function InputAdapter(props) {\\n    var _this3;\\n\\n    _classCallCheck(this, InputAdapter);\\n\\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(InputAdapter).call(this, props));\\n    _this3._getRef = _this3._getRef.bind(_assertThisInitialized(_assertThisInitialized(_this3)));\\n    _this3._onChange = _this3._onChange.bind(_assertThisInitialized(_assertThisInitialized(_this3)));\\n    return _this3;\\n  }\\n\\n  _createClass(InputAdapter, [{\\n    key: \\\"componentDidMount\\\",\\n    value: function componentDidMount() {\\n      this._setCaretPosition();\\n    }\\n  }, {\\n    key: \\\"componentDidUpdate\\\",\\n    value: function componentDidUpdate() {\\n      this._setCaretPosition();\\n    }\\n  }, {\\n    key: \\\"_getRef\\\",\\n    value: function _getRef(ref) {\\n      this.input = ref;\\n    }\\n  }, {\\n    key: \\\"_onChange\\\",\\n    value: function _onChange(event) {\\n      event.persist();\\n      this.props.onChange(event);\\n    }\\n  }, {\\n    key: \\\"_setCaretPosition\\\",\\n    value: function _setCaretPosition() {\\n      var _this4 = this;\\n\\n      if (isDocument && this.input === document.activeElement) {\\n        if (isAndroid === true) {\\n          setTimeout(function () {\\n            _this4.input.setSelectionRange(_this4.props.caretPosition, _this4.props.caretPosition, 'none');\\n          }, 0);\\n        } else {\\n          this.input.setSelectionRange(this.props.caretPosition, this.props.caretPosition, 'none');\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"render\\\",\\n    value: function render() {\\n      var _this$props = this.props,\\n          rest = _objectWithoutPropertiesLoose(_this$props, [\\\"caretPosition\\\", \\\"onChange\\\"]);\\n\\n      return React.createElement(\\\"input\\\", _extends({\\n        ref: this._getRef,\\n        type: \\\"text\\\",\\n        onChange: this._onChange\\n      }, rest));\\n    }\\n  }, {\\n    key: \\\"caretPosition\\\",\\n    get: function get() {\\n      return this.input.selectionEnd;\\n    }\\n  }]);\\n\\n  return InputAdapter;\\n}(React.PureComponent);\\n\\nvar SpanAdapter =\\n/*#__PURE__*/\\nfunction (_React$PureComponent3) {\\n  _inherits(SpanAdapter, _React$PureComponent3);\\n\\n  function SpanAdapter() {\\n    _classCallCheck(this, SpanAdapter);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(SpanAdapter).apply(this, arguments));\\n  }\\n\\n  _createClass(SpanAdapter, [{\\n    key: \\\"render\\\",\\n    value: function render() {\\n      var _this$props = this.props,\\n          value = _this$props.value,\\n          rest = _objectWithoutPropertiesLoose(_this$props, [\\\"value\\\", \\\"caretPosition\\\", \\\"onChange\\\"]);\\n\\n      return React.createElement(\\\"span\\\", rest, value);\\n    }\\n  }, {\\n    key: \\\"caretPosition\\\",\\n    // eslint-disable-next-line class-methods-use-this\\n    get: function get() {\\n      return 0;\\n    }\\n  }]);\\n\\n  return SpanAdapter;\\n}(React.PureComponent);\\n\\nexport { TextMask, InputAdapter, SpanAdapter, TextMaskTransformer };\",\"var hasOwnProperty = Object.prototype.hasOwnProperty;\\n\\nfunction transformEntryEqual(a, b) {\\n  for (var k in a) {\\n    if (hasOwnProperty.call(a, k)) {\\n      return a[k] === b[k];\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction transformEqual(a, b) {\\n  if (!a && !b || a === b) {\\n    return true;\\n  }\\n\\n  if (!a !== !b) {\\n    return false;\\n  }\\n\\n  if (a.length !== b.length) {\\n    return false;\\n  }\\n\\n  for (var i = 0; i < a.length; i++) {\\n    if (!transformEntryEqual(a[i], b[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nfunction shallowObjectEquals(a, b) {\\n  var k;\\n  var i = 0;\\n  var j = 0;\\n\\n  for (k in a) {\\n    if (hasOwnProperty.call(a, k)) {\\n      switch (k) {\\n        case 'transform':\\n          if (!transformEqual(a[k], b[k])) {\\n            return false;\\n          }\\n\\n          break;\\n\\n        case 'shadowOffset':\\n          if (!shallowObjectEquals(a[k], b[k])) {\\n            return false;\\n          }\\n\\n          break;\\n\\n        default:\\n          if (a[k] !== b[k]) {\\n            return false;\\n          }\\n\\n          break;\\n      }\\n\\n      i++;\\n    }\\n  }\\n\\n  for (k in b) {\\n    if (hasOwnProperty.call(b, k)) {\\n      j++;\\n    }\\n  }\\n\\n  return i === j;\\n}\\n\\nfunction styleEqual(a, b) {\\n  if (!a && !b || a === b) {\\n    return true;\\n  }\\n\\n  if (!a !== !b) {\\n    return false;\\n  }\\n\\n  switch (typeof a) {\\n    case 'object':\\n      if (a instanceof Array) {\\n        for (var i = 0; i < a.length; i++) {\\n          if (!styleEqual(a[i], b[i])) {\\n            return false;\\n          }\\n        }\\n\\n        return a.length === b.length;\\n      } else {\\n        return shallowObjectEquals(a, b);\\n      }\\n\\n      break;\\n\\n    case 'number':\\n    default:\\n      return a === b;\\n  }\\n}\\n\\nmodule.exports = styleEqual;\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{623:function(e,t,n){\"use strict\";var r=n(11),o=n(9),i=n(10),a=n(36),u=n(7),s=n(8),l=n(1),c=n.n(l),f=n(819),h=n.n(f),p=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e};function v(e){return null===e?\"null\":Array.isArray(e)?\"array\":\"undefined\"===typeof e?\"undefined\":p(e)}function d(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=Object.keys(e),o=0,i=0,a=0,u=r.length;a<u;a++){var s=r[a];if(!n.ignore||-1===n.ignore.indexOf(s)){if(\"style\"!==s&&\"children\"!==s&&e[s]!==t[s])return!1;o+=1}}for(var l=Object.keys(t),c=0,f=l.length;c<f;c++){var p=l[c];n.ignore&&-1!==n.ignore.indexOf(p)||(i+=1)}return o===i&&(!!h()(e.style,t.style)&&function e(t,n){var r=v(t);if(r!==v(n))return!1;switch(r){case\"array\":if(t.length!==n.length)return!1;for(var o=0;o<t.length;o++)if(!e(t[o],n[o]))return!1;return!0;case\"object\":return t.type===n.type&&t.key===n.key&&t.ref===n.ref&&d(t.props,n.props);default:return t===n}}(e.children,t.children))}function g(){return(g=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function m(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}n.d(t,\"b\",function(){return M}),n.d(t,\"a\",function(){return N});var y=[],C=\"\";var b=\"_\",k=\"function\",P=[];function O(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:P,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:b;if(!w(e))throw new Error(\"Text-mask:convertMaskToPlaceholder; The mask property must be an array.\");if(-1!==e.indexOf(t))throw new Error(\"Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.\\n\\n\"+\"The placeholder character that was received is: \".concat(JSON.stringify(t),\"\\n\\n\")+\"The mask that was received is: \".concat(JSON.stringify(e)));return e.map(function(e){return e instanceof RegExp?t:e}).join(\"\")}function w(e){return Array.isArray&&Array.isArray(e)||e instanceof Array}function j(e){return\"string\"===typeof e||e instanceof String}var x=\"[]\";function _(e){for(var t,n=[];-1!==(t=e.indexOf(x));)n.push(t),e.splice(t,1);return{maskWithoutCaretTraps:e,indexes:n}}var T=[],V=\"\";function R(e){if(null==e)return\"\";if(j(e))return e;if(\"number\"===typeof(t=e)&&void 0===t.length&&!isNaN(t))return String(e);var t;throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \"+\"received was:\\n\\n \".concat(JSON.stringify(e)))}var S=function(){function e(){Object(u.a)(this,e),this.previousConformedValue=void 0,this.previousPlaceholder=void 0}return Object(s.a)(e,[{key:\"update\",value:function(e){var t,n,r=e.value,o=e.caretPosition,i=e.mask,a=e.guide,u=e.pipe,s=e.placeholderChar,l=void 0===s?b:s,c=e.keepCharPositions,f=void 0!==c&&c,h=e.showMask,p=void 0!==h&&h;if(r===this.previousConformedValue)return null;null!=i&&\"object\"===typeof i&&null!=i.pipe&&null!=i.mask&&(u=i.pipe,i=i.mask),Array.isArray(i)&&(t=O(i,l));var v,d=R(r);if(!1===i)return{value:d,caretPosition:o};if(\"function\"===typeof i){if(!1===(n=i(d,{currentCaretPosition:o,previousConformedValue:this.previousConformedValue,placeholderChar:l})))return null;var m=_(n),P=m.maskWithoutCaretTraps;v=m.indexes,t=O(n=P,l)}else n=i;var x={previousConformedValue:this.previousConformedValue,guide:a,placeholderChar:l,pipe:u,placeholder:t,currentCaretPosition:o,keepCharPositions:f},S=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:V,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:T,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!w(t)){if(typeof t!==k)throw new Error(\"Text-mask:conformToMask; The mask property must be an array.\");t=_(t=t(e,n)).maskWithoutCaretTraps}var r=n.guide,o=void 0===r||r,i=n.previousConformedValue,a=void 0===i?V:i,u=n.placeholderChar,s=void 0===u?b:u,l=n.placeholder,c=void 0===l?O(t,s):l,f=n.currentCaretPosition,h=n.keepCharPositions,p=!1===o&&void 0!==a,v=e.length,d=a.length,g=c.length,m=t.length,y=v-d,C=y>0,P=f+(C?-y:0),j=P+Math.abs(y);if(!0===h&&!C){for(var x=V,R=P;R<j;R++)c[R]===s&&(x+=s);e=e.slice(0,P)+x+e.slice(P,v)}for(var S=e.split(V).map(function(e,t){return{char:e,isNew:t>=P&&t<j}}),M=v-1;M>=0;M--){var A=S[M].char;A!==s&&A===c[M>=P&&d===m?M-y:M]&&S.splice(M,1)}var E=V,N=!1;e:for(var J=0;J<g;J++){var W=c[J];if(W===s){if(S.length>0)for(;S.length>0;){var D=S.shift(),I=D.char,L=D.isNew;if(I===s&&!0!==p){E+=s;continue e}if(t[J].test(I)){if(!0===h&&!1!==L&&a!==V&&!1!==o&&C){for(var U=S.length,q=null,z=0;z<U;z++){var B=S[z];if(B.char!==s&&!1===B.isNew)break;if(B.char===s){q=z;break}}null!==q?(E+=I,S.splice(q,1)):J--}else E+=I;continue e}N=!0}!1===p&&(E+=c.substr(J,g));break}E+=W}if(p&&!1===C){for(var F=null,G=0;G<E.length;G++)c[G]===s&&(F=G);E=null!==F?E.substr(0,F+1):V}return{conformedValue:E,meta:{someCharsRejected:N}}}(d,n,x).conformedValue,M=\"function\"===typeof u,A={};M&&(!1===(A=u(S,g({rawValue:d},x)))?A={value:this.previousConformedValue,rejected:!0}:j(A)&&(A={value:A}));var E=M?A.value:S,N=function(e){var t=e.previousConformedValue,n=void 0===t?C:t,r=e.previousPlaceholder,o=void 0===r?C:r,i=e.currentCaretPosition,a=void 0===i?0:i,u=e.conformedValue,s=e.rawValue,l=e.placeholderChar,c=e.placeholder,f=e.indexesOfPipedChars,h=void 0===f?y:f,p=e.caretTrapIndexes,v=void 0===p?y:p;if(0===a||!s.length)return 0;var d=s.length,g=n.length,m=c.length,b=u.length,k=d-g,P=k>0;if(k>1&&!P&&0!==g)return a;var O,w,j=0;if(!P||n!==u&&u!==c){var x=u.toLowerCase(),_=s.toLowerCase().substr(0,a).split(C).filter(function(e){return-1!==x.indexOf(e)});w=_[_.length-1];var T=o.substr(0,_.length).split(C).filter(function(e){return e!==l}).length,V=c.substr(0,_.length).split(C).filter(function(e){return e!==l}).length!==T,R=void 0!==o[_.length-1]&&void 0!==c[_.length-2]&&o[_.length-1]!==l&&o[_.length-1]!==c[_.length-1]&&o[_.length-1]===c[_.length-2];!P&&(V||R)&&T>0&&c.indexOf(w)>-1&&void 0!==s[a]&&(O=!0,w=s[a]);for(var S=h.map(function(e){return x[e]}).filter(function(e){return e===w}).length,M=_.filter(function(e){return e===w}).length,A=c.substr(0,c.indexOf(l)).split(C).filter(function(e,t){return e===w&&s[t]!==e}).length+M+S+(O?1:0),E=0,N=0;N<b&&(j=N+1,x[N]===w&&E++,!(E>=A));N++);}else j=a-k;if(P){for(var J=j,W=j;W<=m;W++)if(c[W]===l&&(J=W),c[W]===l||-1!==v.indexOf(W)||W===m)return J}else if(O){for(var D=j-1;D>=0;D--)if(u[D]===w||-1!==v.indexOf(D)||0===D)return D}else for(var I=j;I>=0;I--)if(c[I-1]===l||-1!==v.indexOf(I)||0===I)return I}({previousConformedValue:this.previousConformedValue,previousPlaceholder:this.previousPlaceholder,conformedValue:E,placeholder:t,rawValue:d,currentCaretPosition:o,placeholderChar:l,indexesOfPipedChars:A.indexesOfPipedChars,caretTrapIndexes:v}),J=E===t&&0===N?p?t:\"\":E;return this.previousConformedValue=J,this.previousPlaceholder=t,{value:J,caretPosition:N}}}]),e}(),M=function(e){function t(e,n){var i;Object(u.a)(this,t),(i=Object(r.a)(this,Object(o.a)(t).call(this,e,n)))._update=i._update.bind(Object(a.a)(Object(a.a)(i))),i._getRef=i._getRef.bind(Object(a.a)(Object(a.a)(i))),i._onChange=i._onChange.bind(Object(a.a)(Object(a.a)(i))),i.component=null,i.textMaskTransformer=new S;var s=null!=e.value?e.value:\"\",l=i._update(g({},e,{value:s}));return i.state=null!==l?{value:l.value,caretPosition:l.caretPosition}:{value:\"\",caretPosition:0},i}return Object(i.a)(t,e),Object(s.a)(t,[{key:\"componentWillReceiveProps\",value:function(e){var t=[];if(!1===e.isControlled&&t.push(\"value\"),!d(this.props,e,{ignore:t})){var n=!0===e.isControlled&&null!=e.value?e.value:this.state.value,r=this._update(g({},e,{value:n}));null!==r&&this.setState(r)}}},{key:\"_update\",value:function(e){return this.textMaskTransformer.update({value:e.value,caretPosition:null!=this.component?this.component.caretPosition:0,mask:e.mask,guide:e.guide,pipe:e.pipe,placeholderChar:e.placeholderChar,keepCharPositions:e.keepCharPositions,showMask:e.showMask})}},{key:\"_getRef\",value:function(e){e&&(this.props.componentRef(e),this.component=e)}},{key:\"_onChange\",value:function(e){var t=this;if(e){var n=\"object\"===typeof e.target?e.target.value:e.text,r=this._update(g({},this.props,{value:n}));null!==r?this.setState(r,function(){t.props.onChange(e,r)}):(this.props.onChange(e,this.state),this.forceUpdate())}}},{key:\"focus\",value:function(){this.component.input&&this.component.input.focus()}},{key:\"blur\",value:function(){this.component.input&&this.component.input.blur()}},{key:\"render\",value:function(){var e=this.props,t=e.Component,n=m(e,[\"Component\",\"value\",\"isControlled\",\"mask\",\"guide\",\"pipe\",\"placeholderChar\",\"keepCharPositions\",\"showMask\",\"componentRef\",\"onChange\"]);return c.a.createElement(t,g({},n,{value:this.state.value,caretPosition:this.state.caretPosition,onChange:this._onChange,ref:this._getRef}))}},{key:\"value\",get:function(){return this.state.value}}]),t}(c.a.PureComponent);M.defaultProps={value:null,isControlled:!0,guide:!0,pipe:null,placeholderChar:\"_\",keepCharPositions:!1,showMask:!1,onChange:function(){},componentRef:function(){}};var A=\"undefined\"!==typeof navigator&&null!==navigator&&/android/i.test(navigator.userAgent),E=\"undefined\"!==typeof document&&null!==document,N=function(e){function t(e){var n;return Object(u.a)(this,t),(n=Object(r.a)(this,Object(o.a)(t).call(this,e)))._getRef=n._getRef.bind(Object(a.a)(Object(a.a)(n))),n._onChange=n._onChange.bind(Object(a.a)(Object(a.a)(n))),n}return Object(i.a)(t,e),Object(s.a)(t,[{key:\"componentDidMount\",value:function(){this._setCaretPosition()}},{key:\"componentDidUpdate\",value:function(){this._setCaretPosition()}},{key:\"_getRef\",value:function(e){this.input=e}},{key:\"_onChange\",value:function(e){e.persist(),this.props.onChange(e)}},{key:\"_setCaretPosition\",value:function(){var e=this;E&&this.input===document.activeElement&&(!0===A?setTimeout(function(){e.input.setSelectionRange(e.props.caretPosition,e.props.caretPosition,\"none\")},0):this.input.setSelectionRange(this.props.caretPosition,this.props.caretPosition,\"none\"))}},{key:\"render\",value:function(){var e=m(this.props,[\"caretPosition\",\"onChange\"]);return c.a.createElement(\"input\",g({ref:this._getRef,type:\"text\",onChange:this._onChange},e))}},{key:\"caretPosition\",get:function(){return this.input.selectionEnd}}]),t}(c.a.PureComponent);c.a.PureComponent},819:function(e,t){var n=Object.prototype.hasOwnProperty;function r(e,t){for(var r in e)if(n.call(e,r))return e[r]===t[r];return!1}function o(e,t){if(!e&&!t||e===t)return!0;if(!e!==!t)return!1;if(e.length!==t.length)return!1;for(var n=0;n<e.length;n++)if(!r(e[n],t[n]))return!1;return!0}e.exports=function e(t,r){if(!t&&!r||t===r)return!0;if(!t!==!r)return!1;switch(typeof t){case\"object\":if(t instanceof Array){for(var i=0;i<t.length;i++)if(!e(t[i],r[i]))return!1;return t.length===r.length}return function e(t,r){var i,a=0,u=0;for(i in t)if(n.call(t,i)){switch(i){case\"transform\":if(!o(t[i],r[i]))return!1;break;case\"shadowOffset\":if(!e(t[i],r[i]))return!1;break;default:if(t[i]!==r[i])return!1}a++}for(i in r)n.call(r,i)&&u++;return a===u}(t,r);case\"number\":default:return t===r}}}}]);","extractedComments":[]}